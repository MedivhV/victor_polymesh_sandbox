"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.modifyInstructionAffirmation = exports.prepareStorage = exports.getAuthorization = exports.prepareModifyInstructionAffirmation = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bluebird_1 = __importDefault(require("bluebird"));
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const utils_2 = require("../../types/utils");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
const getAssetCount = (rawId, context) => __awaiter(void 0, void 0, void 0, function* () {
    const { polymeshApi: { call }, } = context;
    const { fungibleTokens: fungible, nonFungibleTokens: nonFungible, offChainAssets: offChain, } = yield call.settlementApi.getExecuteInstructionInfo(rawId);
    return (0, conversion_1.assetCountToRaw)({ fungible, nonFungible, offChain }, context);
});
/**
 * @hidden
 */
const assertPortfoliosValid = (portfolioParams, portfolios, operation) => {
    if (operation === types_1.InstructionAffirmationOperation.AffirmAsMediator ||
        operation === types_1.InstructionAffirmationOperation.RejectAsMediator ||
        operation === types_1.InstructionAffirmationOperation.WithdrawAsMediator) {
        return;
    }
    if (portfolioParams.length && portfolioParams.length !== portfolios.length) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnmetPrerequisite,
            message: 'Some of the portfolios are not a involved in this instruction',
        });
    }
    if (!portfolios.length) {
        throw new internal_1.PolymeshError({
            code: types_1.ErrorCode.UnmetPrerequisite,
            message: 'The signing Identity is not involved in this Instruction',
        });
    }
};
/**
 * @hidden
 */
function prepareModifyInstructionAffirmation(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { settlement: settlementTx }, query: { settlement }, call, }, }, context, storage: { portfolios, portfolioParams, senderLegAmount, totalLegAmount, signer }, } = this;
        const { operation, id } = args;
        const instruction = new internal_1.Instruction({ id }, context);
        yield Promise.all([(0, utils_1.assertInstructionValid)(instruction, context)]);
        assertPortfoliosValid(portfolioParams, portfolios, operation);
        const rawInstructionId = (0, conversion_1.bigNumberToU64)(id, context);
        const rawPortfolioIds = portfolios.map(portfolio => (0, conversion_1.portfolioIdToMeshPortfolioId)((0, conversion_1.portfolioLikeToPortfolioId)(portfolio), context));
        const rawDid = (0, conversion_1.stringToIdentityId)(signer.did, context);
        const multiArgs = rawPortfolioIds.map(portfolioId => (0, utils_2.tuple)(portfolioId, rawInstructionId));
        const [rawAffirmationStatuses, rawMediatorAffirmation] = yield Promise.all([
            settlement.userAffirmations.multi(multiArgs),
            settlement.instructionMediatorsAffirmations(rawInstructionId, rawDid),
        ]);
        const affirmationStatuses = rawAffirmationStatuses.map(conversion_1.meshAffirmationStatusToAffirmationStatus);
        const { status: mediatorStatus, expiry } = (0, conversion_1.mediatorAffirmationStatusToStatus)(rawMediatorAffirmation);
        const excludeCriteria = [];
        let errorMessage;
        let transaction = null;
        switch (operation) {
            case types_1.InstructionAffirmationOperation.AffirmAsMediator: {
                if (mediatorStatus === types_1.AffirmationStatus.Unknown) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.ValidationError,
                        message: 'The signer is not a mediator',
                        data: { signer: signer.did, instructionId: id.toString() },
                    });
                }
                const givenExpiry = args.expiry;
                const now = new Date();
                if (givenExpiry && givenExpiry < now) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.ValidationError,
                        message: 'The expiry must be in the future',
                        data: { expiry, now },
                    });
                }
                const rawExpiry = (0, internal_2.optionize)(conversion_1.dateToMoment)(givenExpiry, context);
                return {
                    transaction: settlementTx.affirmInstructionAsMediator,
                    resolver: instruction,
                    args: [rawInstructionId, rawExpiry],
                };
            }
            case types_1.InstructionAffirmationOperation.WithdrawAsMediator: {
                if (mediatorStatus !== types_1.AffirmationStatus.Affirmed) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.ValidationError,
                        message: 'The signer is not a mediator that has already affirmed the instruction',
                        data: { signer: signer.did, instructionId: id.toString() },
                    });
                }
                return {
                    transaction: settlementTx.withdrawAffirmationAsMediator,
                    resolver: instruction,
                    args: [rawInstructionId],
                };
            }
            case types_1.InstructionAffirmationOperation.RejectAsMediator: {
                if (mediatorStatus === types_1.AffirmationStatus.Unknown) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.ValidationError,
                        message: 'The signer is not a mediator for the instruction',
                        data: { did: signer.did, instructionId: id.toString() },
                    });
                }
                const rawAssetCount = yield getAssetCount(rawInstructionId, context);
                return {
                    transaction: settlementTx.rejectInstructionAsMediator,
                    resolver: instruction,
                    args: [rawInstructionId, rawAssetCount],
                };
            }
            case types_1.InstructionAffirmationOperation.Reject: {
                const rawAssetCount = yield getAssetCount(rawInstructionId, context);
                return {
                    transaction: settlementTx.rejectInstructionWithCount,
                    resolver: instruction,
                    feeMultiplier: totalLegAmount,
                    args: [rawInstructionId, rawPortfolioIds[0], rawAssetCount],
                };
            }
            case types_1.InstructionAffirmationOperation.Affirm: {
                excludeCriteria.push(types_1.AffirmationStatus.Affirmed);
                errorMessage = 'The Instruction is already affirmed';
                transaction = settlementTx.affirmInstructionWithCount;
                break;
            }
            case types_1.InstructionAffirmationOperation.Withdraw: {
                excludeCriteria.push(types_1.AffirmationStatus.Pending);
                errorMessage = 'The instruction is not affirmed';
                transaction = settlementTx.withdrawAffirmationWithCount;
                break;
            }
        }
        const validPortfolioIds = rawPortfolioIds.filter((_, index) => !excludeCriteria.includes(affirmationStatuses[index]));
        if (!validPortfolioIds.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.NoDataChange,
                message: errorMessage,
            });
        }
        const rawAffirmCount = yield call.settlementApi.getAffirmationCount(rawInstructionId, rawPortfolioIds);
        return {
            transaction,
            resolver: instruction,
            feeMultiplier: senderLegAmount,
            args: [rawInstructionId, validPortfolioIds, rawAffirmCount],
        };
    });
}
exports.prepareModifyInstructionAffirmation = prepareModifyInstructionAffirmation;
/**
 * @hidden
 */
function getAuthorization({ operation }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { storage: { portfolios }, } = this;
        let transactions;
        switch (operation) {
            case types_1.InstructionAffirmationOperation.Affirm: {
                transactions = [types_1.TxTags.settlement.AffirmInstruction];
                break;
            }
            case types_1.InstructionAffirmationOperation.Withdraw: {
                transactions = [types_1.TxTags.settlement.WithdrawAffirmation];
                break;
            }
            case types_1.InstructionAffirmationOperation.Reject: {
                transactions = [types_1.TxTags.settlement.RejectInstruction];
                break;
            }
            case types_1.InstructionAffirmationOperation.AffirmAsMediator: {
                transactions = [types_1.TxTags.settlement.AffirmInstructionAsMediator];
                break;
            }
            case types_1.InstructionAffirmationOperation.WithdrawAsMediator: {
                transactions = [types_1.TxTags.settlement.WithdrawAffirmationAsMediator];
                break;
            }
            case types_1.InstructionAffirmationOperation.RejectAsMediator: {
                transactions = [types_1.TxTags.settlement.RejectInstructionAsMediator];
                break;
            }
        }
        return {
            permissions: {
                portfolios,
                transactions,
                assets: [],
            },
        };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function extractPortfolioParams(params) {
    const { operation } = params;
    let portfolioParams = [];
    if (operation === types_1.InstructionAffirmationOperation.Reject) {
        const { portfolio } = params;
        if (portfolio) {
            portfolioParams.push(portfolio);
        }
    }
    else if (operation === types_1.InstructionAffirmationOperation.Affirm ||
        operation === types_1.InstructionAffirmationOperation.Withdraw) {
        const { portfolios } = params;
        if (portfolios) {
            portfolioParams = [...portfolioParams, ...portfolios];
        }
    }
    return portfolioParams;
}
/**
 * @hidden
 */
const isParam = (legPortfolio, portfolioIdParams) => {
    const { did: legPortfolioDid, number: legPortfolioNumber } = (0, conversion_1.portfolioLikeToPortfolioId)(legPortfolio);
    return (!portfolioIdParams.length ||
        portfolioIdParams.some(({ did, number }) => did === legPortfolioDid &&
            new bignumber_js_1.default(legPortfolioNumber || 0).eq(new bignumber_js_1.default(number || 0))));
};
/**
 * @hidden
 */
const assemblePortfolios = (result, from, to, signingDid, portfolioIdParams) => __awaiter(void 0, void 0, void 0, function* () {
    const [fromExists, toExists] = yield Promise.all([from.exists(), to.exists()]);
    const [custodiedPortfolios, amount] = result;
    let res = [...custodiedPortfolios];
    let legAmount = amount;
    const checkCustody = (legPortfolio, exists, sender) => __awaiter(void 0, void 0, void 0, function* () {
        if (exists) {
            const isCustodied = yield legPortfolio.isCustodiedBy({ identity: signingDid });
            if (isCustodied) {
                res = [...res, legPortfolio];
                if (sender) {
                    legAmount = legAmount.plus(1);
                }
            }
        }
        else if (legPortfolio.owner.did === signingDid) {
            res = [...res, legPortfolio];
        }
    });
    const promises = [];
    if (isParam(from, portfolioIdParams)) {
        promises.push(checkCustody(from, fromExists, true));
    }
    if (isParam(to, portfolioIdParams)) {
        promises.push(checkCustody(to, toExists, false));
    }
    yield Promise.all(promises);
    return (0, utils_2.tuple)(res, legAmount);
});
/**
 * @hidden
 */
function prepareStorage(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context, context: { polymeshApi }, } = this;
        const { id } = params;
        const rawId = (0, conversion_1.bigNumberToU64)(id, context);
        const portfolioParams = extractPortfolioParams(params);
        const portfolioIdParams = portfolioParams.map(conversion_1.portfolioLikeToPortfolioId);
        const instruction = new internal_1.Instruction({ id }, context);
        const [{ data: legs }, signer] = yield Promise.all([
            instruction.getLegs(),
            context.getSigningIdentity(),
            polymeshApi.call.settlementApi.getExecuteInstructionInfo(rawId),
        ]);
        const [portfolios, senderLegAmount] = yield bluebird_1.default.reduce(legs, (result, { from, to }) => __awaiter(this, void 0, void 0, function* () { return assemblePortfolios(result, from, to, signer.did, portfolioIdParams); }), [[], new bignumber_js_1.default(0)]);
        return {
            portfolios,
            portfolioParams,
            senderLegAmount,
            totalLegAmount: new bignumber_js_1.default(legs.length),
            signer,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const modifyInstructionAffirmation = () => new internal_1.Procedure(prepareModifyInstructionAffirmation, getAuthorization, prepareStorage);
exports.modifyInstructionAffirmation = modifyInstructionAffirmation;
//# sourceMappingURL=modifyInstructionAffirmation.js.map