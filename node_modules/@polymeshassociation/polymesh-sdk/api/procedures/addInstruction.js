"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addInstruction = exports.prepareStorage = exports.getAuthorization = exports.prepareAddInstruction = exports.createAddInstructionResolver = void 0;
const bluebird_1 = __importDefault(require("bluebird"));
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const utils_2 = require("../../utils");
const constants_1 = require("../../utils/constants");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
const createAddInstructionResolver = (context) => (receipt) => {
    const events = (0, internal_2.filterEventRecords)(receipt, 'settlement', 'InstructionCreated');
    const result = events.map(({ data }) => new internal_1.Instruction({ id: (0, conversion_1.u64ToBigNumber)(data[2]) }, context));
    return result;
};
exports.createAddInstructionResolver = createAddInstructionResolver;
/**
 * @hidden
 */
function getEndCondition(instruction, latestBlock, index) {
    let endCondition;
    let errorIndex = null;
    if ('endBlock' in instruction && instruction.endBlock) {
        const { endBlock } = instruction;
        if (endBlock.lte(latestBlock)) {
            errorIndex = index;
        }
        endCondition = { type: types_1.InstructionType.SettleOnBlock, endBlock };
    }
    else if ('endAfterBlock' in instruction && instruction.endAfterBlock) {
        endCondition = { type: types_1.InstructionType.SettleManual, endAfterBlock: instruction.endAfterBlock };
    }
    else {
        endCondition = { type: types_1.InstructionType.SettleOnAffirmation };
    }
    return {
        endCondition,
        errorIndex,
    };
}
/**
 * @hidden
 */
function separateLegs(legs, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const fungibleLegs = [];
        const nftLegs = [];
        for (const leg of legs) {
            const ticker = (0, internal_2.asTicker)(leg.asset);
            const [isFungible, isNft] = yield Promise.all([
                (0, utils_2.isFungibleLegBuilder)(leg, context),
                (0, utils_2.isNftLegBuilder)(leg, context),
            ]);
            if (isFungible(leg)) {
                if (!('amount' in leg)) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.ValidationError,
                        message: 'The key "amount" should be present in a fungible leg',
                        data: { ticker },
                    });
                }
                fungibleLegs.push(leg);
            }
            else if (isNft(leg)) {
                if (!('nfts' in leg)) {
                    throw new internal_1.PolymeshError({
                        code: types_1.ErrorCode.ValidationError,
                        message: 'The key "nfts" should be present in an NFT leg',
                        data: { ticker },
                    });
                }
                nftLegs.push(leg);
            }
        }
        return { fungibleLegs, nftLegs };
    });
}
/**
 * @hidden
 */
function assertVenueFiltering(instructions, venueId, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const assets = instructions.flatMap(instruction => {
            return instruction.legs.map(leg => (0, internal_2.asBaseAsset)(leg.asset, context));
        });
        const venueFiltering = yield Promise.all(assets.map(asset => asset.getVenueFilteringDetails()));
        // finds the intersection of possible venues for the given assets
        const permittedVenues = venueFiltering.reduce((acc, { isEnabled, allowedVenues }) => {
            if (isEnabled) {
                if (acc === undefined) {
                    acc = allowedVenues;
                }
                else {
                    acc = acc.filter(venue => allowedVenues.some(({ id }) => venue.id.eq(id)));
                }
            }
            return acc;
        }, undefined);
        if (permittedVenues !== undefined && !permittedVenues.some(({ id }) => id.eq(venueId))) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnmetPrerequisite,
                message: 'One or more assets are not allowed to be traded at this venue',
                data: {
                    possibleVenues: permittedVenues.map(venue => venue.id.toString()),
                    venueId: venueId.toString(),
                },
            });
        }
    });
}
/**
 * @hidden
 */
function getTxArgsAndErrors(instructions, portfoliosToAffirm, latestBlock, venueId, context) {
    return __awaiter(this, void 0, void 0, function* () {
        const addAndAffirmInstructionParams = [];
        const addInstructionParams = [];
        const legEmptyErrIndexes = [];
        const legLengthErrIndexes = [];
        const legAmountErrIndexes = [];
        const endBlockErrIndexes = [];
        const sameIdentityErrIndexes = [];
        /**
         * array of indexes of Instructions where the value date is before the trade date
         */
        const datesErrIndexes = [];
        yield bluebird_1.default.each(instructions, (instruction, i) => __awaiter(this, void 0, void 0, function* () {
            const { legs, tradeDate, valueDate, memo, mediators } = instruction;
            if (!legs.length) {
                legEmptyErrIndexes.push(i);
            }
            if (legs.length > constants_1.MAX_LEGS_LENGTH) {
                legLengthErrIndexes.push(i);
            }
            const { fungibleLegs, nftLegs } = yield separateLegs(legs, context);
            const zeroAmountFungibleLegs = fungibleLegs.filter(leg => leg.amount.isZero());
            if (zeroAmountFungibleLegs.length) {
                legAmountErrIndexes.push(i);
            }
            const zeroNftsNonFungible = nftLegs.filter(leg => leg.nfts.length === 0);
            if (zeroNftsNonFungible.length) {
                legAmountErrIndexes.push(i);
            }
            const sameIdentityLegs = legs.filter(({ from, to }) => {
                const fromId = (0, conversion_1.portfolioLikeToPortfolioId)(from);
                const toId = (0, conversion_1.portfolioLikeToPortfolioId)(to);
                return fromId.did === toId.did;
            });
            if (sameIdentityLegs.length) {
                sameIdentityErrIndexes.push(i);
            }
            const { endCondition, errorIndex } = getEndCondition(instruction, latestBlock, i);
            if (errorIndex !== null) {
                endBlockErrIndexes.push(errorIndex);
            }
            if (tradeDate && valueDate && tradeDate > valueDate) {
                datesErrIndexes.push(i);
            }
            if (!legEmptyErrIndexes.length &&
                !legLengthErrIndexes.length &&
                !legAmountErrIndexes.length &&
                !endBlockErrIndexes.length &&
                !datesErrIndexes.length &&
                !sameIdentityErrIndexes.length) {
                const rawVenueId = (0, conversion_1.bigNumberToU64)(venueId, context);
                const rawSettlementType = (0, conversion_1.endConditionToSettlementType)(endCondition, context);
                const rawTradeDate = (0, internal_2.optionize)(conversion_1.dateToMoment)(tradeDate, context);
                const rawValueDate = (0, internal_2.optionize)(conversion_1.dateToMoment)(valueDate, context);
                const rawLegs = [];
                const rawInstructionMemo = (0, internal_2.optionize)(conversion_1.stringToMemo)(memo, context);
                const mediatorIds = mediators === null || mediators === void 0 ? void 0 : mediators.map(mediator => (0, internal_2.asIdentity)(mediator, context));
                const rawMediators = (0, conversion_1.identitiesToBtreeSet)(mediatorIds !== null && mediatorIds !== void 0 ? mediatorIds : [], context);
                yield Promise.all([
                    ...fungibleLegs.map(({ from, to, amount, asset }) => __awaiter(this, void 0, void 0, function* () {
                        const fromId = (0, conversion_1.portfolioLikeToPortfolioId)(from);
                        const toId = (0, conversion_1.portfolioLikeToPortfolioId)(to);
                        yield Promise.all([
                            (0, utils_1.assertPortfolioExists)(fromId, context),
                            (0, utils_1.assertPortfolioExists)(toId, context),
                            (0, utils_1.assertValidCdd)(fromId.did, context),
                            (0, utils_1.assertValidCdd)(toId.did, context),
                        ]);
                        const rawFromPortfolio = (0, conversion_1.portfolioIdToMeshPortfolioId)(fromId, context);
                        const rawToPortfolio = (0, conversion_1.portfolioIdToMeshPortfolioId)(toId, context);
                        const rawLeg = (0, conversion_1.legToFungibleLeg)({
                            sender: rawFromPortfolio,
                            receiver: rawToPortfolio,
                            ticker: (0, conversion_1.stringToTicker)((0, internal_2.asTicker)(asset), context),
                            amount: (0, conversion_1.bigNumberToBalance)(amount, context),
                        }, context);
                        rawLegs.push(rawLeg);
                    })),
                    ...nftLegs.map(({ from, to, nfts, asset }) => __awaiter(this, void 0, void 0, function* () {
                        const fromId = (0, conversion_1.portfolioLikeToPortfolioId)(from);
                        const toId = (0, conversion_1.portfolioLikeToPortfolioId)(to);
                        yield Promise.all([
                            (0, utils_1.assertPortfolioExists)(fromId, context),
                            (0, utils_1.assertPortfolioExists)(toId, context),
                            (0, utils_1.assertValidCdd)(fromId.did, context),
                            (0, utils_1.assertValidCdd)(toId.did, context),
                        ]);
                        const rawFromPortfolio = (0, conversion_1.portfolioIdToMeshPortfolioId)(fromId, context);
                        const rawToPortfolio = (0, conversion_1.portfolioIdToMeshPortfolioId)(toId, context);
                        const rawLeg = (0, conversion_1.legToNonFungibleLeg)({
                            sender: rawFromPortfolio,
                            receiver: rawToPortfolio,
                            nfts: (0, conversion_1.nftToMeshNft)((0, internal_2.asTicker)(asset), nfts, context),
                        }, context);
                        rawLegs.push(rawLeg);
                    })),
                ]);
                if (portfoliosToAffirm[i].length) {
                    addAndAffirmInstructionParams.push([
                        rawVenueId,
                        rawSettlementType,
                        rawTradeDate,
                        rawValueDate,
                        rawLegs,
                        portfoliosToAffirm[i].map(portfolio => (0, conversion_1.portfolioIdToMeshPortfolioId)((0, conversion_1.portfolioLikeToPortfolioId)(portfolio), context)),
                        rawInstructionMemo,
                        rawMediators,
                    ]);
                }
                else {
                    addInstructionParams.push([
                        rawVenueId,
                        rawSettlementType,
                        rawTradeDate,
                        rawValueDate,
                        rawLegs,
                        rawInstructionMemo,
                        rawMediators,
                    ]);
                }
            }
        }));
        return {
            errIndexes: {
                legEmptyErrIndexes,
                legLengthErrIndexes,
                legAmountErrIndexes,
                endBlockErrIndexes,
                datesErrIndexes,
                sameIdentityErrIndexes,
            },
            addAndAffirmInstructionParams,
            addInstructionParams,
        };
    });
}
/**
 * @hidden
 */
function prepareAddInstruction(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx: { settlement }, }, }, context, storage: { portfoliosToAffirm }, } = this;
        const { instructions, venueId } = args;
        yield assertVenueFiltering(instructions, venueId, context);
        const allMediators = instructions.flatMap(({ mediators }) => { var _a; return (_a = mediators === null || mediators === void 0 ? void 0 : mediators.map(mediator => (0, internal_2.asIdentity)(mediator, context))) !== null && _a !== void 0 ? _a : []; });
        const [latestBlock] = yield Promise.all([
            context.getLatestBlock(),
            (0, utils_1.assertVenueExists)(venueId, context),
            ...allMediators.map(mediator => (0, internal_2.assertIdentityExists)(mediator)),
        ]);
        if (!instructions.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'The Instructions array cannot be empty',
            });
        }
        const { errIndexes: { legEmptyErrIndexes, legLengthErrIndexes, legAmountErrIndexes, endBlockErrIndexes, datesErrIndexes, sameIdentityErrIndexes, }, addAndAffirmInstructionParams, addInstructionParams, } = yield getTxArgsAndErrors(instructions, portfoliosToAffirm, latestBlock, venueId, context);
        if (legEmptyErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: "The legs array can't be empty",
                data: {
                    failedInstructionIndexes: legEmptyErrIndexes,
                },
            });
        }
        if (legAmountErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Instruction legs cannot have zero amount',
                data: {
                    failedInstructionIndexes: legAmountErrIndexes,
                },
            });
        }
        if (legLengthErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.LimitExceeded,
                message: 'The legs array exceeds the maximum allowed length',
                data: {
                    maxLength: constants_1.MAX_LEGS_LENGTH,
                    failedInstructionIndexes: legLengthErrIndexes,
                },
            });
        }
        if (endBlockErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'End block must be a future block',
                data: {
                    failedInstructionIndexes: endBlockErrIndexes,
                },
            });
        }
        if (datesErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Value date must be after trade date',
                data: {
                    failedInstructionIndexes: datesErrIndexes,
                },
            });
        }
        if (sameIdentityErrIndexes.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.ValidationError,
                message: 'Instruction leg cannot transfer Assets between same identity',
                data: {
                    failedInstructionIndexes: sameIdentityErrIndexes,
                },
            });
        }
        /**
         * After the upgrade is out, the "withMediator" variants are safe to use exclusively
         */
        const addTx = {
            transaction: settlement.addInstructionWithMediators,
            argsArray: addInstructionParams,
        };
        const addAndAffirmTx = {
            transaction: settlement.addAndAffirmWithMediators,
            argsArray: addAndAffirmInstructionParams,
        };
        const transactions = (0, internal_2.assembleBatchTransactions)([addTx, addAndAffirmTx]);
        return {
            transactions,
            resolver: (0, exports.createAddInstructionResolver)(context),
        };
    });
}
exports.prepareAddInstruction = prepareAddInstruction;
/**
 * @hidden
 */
function getAuthorization({ venueId }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { storage: { portfoliosToAffirm }, } = this;
        const addAndAffirmTag = types_1.TxTags.settlement.AddAndAffirmWithMediators;
        const addInstructionTag = types_1.TxTags.settlement.AddInstructionWithMediators;
        let transactions = [];
        let portfolios = [];
        portfoliosToAffirm.forEach(portfoliosList => {
            transactions = (0, lodash_1.union)(transactions, [
                portfoliosList.length ? addAndAffirmTag : addInstructionTag,
            ]);
            portfolios = (0, lodash_1.unionWith)(portfolios, portfoliosList, lodash_1.isEqual);
        });
        return {
            roles: [{ type: types_1.RoleType.VenueOwner, venueId }],
            permissions: {
                assets: [],
                portfolios,
                transactions,
            },
        };
    });
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
function prepareStorage({ instructions }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context } = this;
        const identity = yield context.getSigningIdentity();
        const portfoliosToAffirm = yield bluebird_1.default.map(instructions, ({ legs }) => __awaiter(this, void 0, void 0, function* () {
            const portfolios = yield bluebird_1.default.map(legs, ({ from, to }) => __awaiter(this, void 0, void 0, function* () {
                const fromPortfolio = (0, conversion_1.portfolioLikeToPortfolio)(from, context);
                const toPortfolio = (0, conversion_1.portfolioLikeToPortfolio)(to, context);
                const result = [];
                const [fromCustodied, toCustodied] = yield Promise.all([
                    fromPortfolio.isCustodiedBy({ identity }),
                    toPortfolio.isCustodiedBy({ identity }),
                ]);
                if (fromCustodied) {
                    result.push(fromPortfolio);
                }
                if (toCustodied) {
                    result.push(toPortfolio);
                }
                return result;
            }));
            return (0, lodash_1.flatten)(portfolios);
        }));
        return {
            portfoliosToAffirm,
        };
    });
}
exports.prepareStorage = prepareStorage;
/**
 * @hidden
 */
const addInstruction = () => new internal_1.Procedure(prepareAddInstruction, getAuthorization, prepareStorage);
exports.addInstruction = addInstruction;
//# sourceMappingURL=addInstruction.js.map