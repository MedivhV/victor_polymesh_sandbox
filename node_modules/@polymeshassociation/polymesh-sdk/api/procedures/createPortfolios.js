"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPortfolios = exports.getAuthorization = exports.prepareCreatePortfolios = exports.createPortfoliosResolver = void 0;
const internal_1 = require("../../internal");
const types_1 = require("../../types");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * @hidden
 */
const createPortfoliosResolver = (context) => (receipt) => {
    const records = (0, internal_2.filterEventRecords)(receipt, 'portfolio', 'PortfolioCreated');
    return records.map(({ data }) => {
        const did = (0, conversion_1.identityIdToString)(data[0]);
        const id = (0, conversion_1.u64ToBigNumber)(data[1]);
        return new internal_1.NumberedPortfolio({ did, id }, context);
    });
};
exports.createPortfoliosResolver = createPortfoliosResolver;
/**
 * @hidden
 */
function prepareCreatePortfolios(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { polymeshApi: { tx }, }, context, } = this;
        const { portfolios: portfoliosToCreate } = args;
        const { did } = yield context.getSigningIdentity();
        const groupedPortfolioNamesByIdentity = portfoliosToCreate.reduce((acc, { name, ownerDid }) => {
            const owner = ownerDid !== null && ownerDid !== void 0 ? ownerDid : did;
            if (!acc[owner]) {
                acc[owner] = [];
            }
            acc[owner].push(name);
            return acc;
        }, {});
        const dids = Object.keys(groupedPortfolioNamesByIdentity);
        const portfolioIdCalls = dids.map(identityId => {
            const rawNames = groupedPortfolioNamesByIdentity[identityId].map(name => (0, conversion_1.stringToBytes)(name, context));
            const rawIdentityId = (0, conversion_1.stringToIdentityId)(identityId, context);
            return (0, internal_2.getPortfolioIdsByName)(rawIdentityId, rawNames, context);
        });
        const foundPortfoliosByDid = yield Promise.all(portfolioIdCalls);
        const existingNames = [];
        foundPortfoliosByDid.forEach((portfolios, index) => {
            portfolios.forEach(id => {
                if (id) {
                    existingNames.push(groupedPortfolioNamesByIdentity[dids[index]][id.toNumber()]);
                }
            });
        });
        if (existingNames.length) {
            throw new internal_1.PolymeshError({
                code: types_1.ErrorCode.UnmetPrerequisite,
                message: 'There already exist Portfolios with some of the given names',
                data: {
                    existingNames,
                },
            });
        }
        const transactions = [];
        portfoliosToCreate.forEach(({ name, ownerDid }) => {
            if (ownerDid) {
                transactions.push((0, internal_2.checkTxType)({
                    transaction: tx.portfolio.createCustodyPortfolio,
                    args: [(0, conversion_1.stringToIdentityId)(ownerDid, context), (0, conversion_1.stringToBytes)(name, context)],
                }));
            }
            else {
                transactions.push((0, internal_2.checkTxType)({
                    transaction: tx.portfolio.createPortfolio,
                    args: [(0, conversion_1.stringToBytes)(name, context)],
                }));
            }
        });
        return {
            transactions,
            resolver: (0, exports.createPortfoliosResolver)(context),
        };
    });
}
exports.prepareCreatePortfolios = prepareCreatePortfolios;
/**
 * @hidden
 */
function getAuthorization({ portfolios }) {
    const transactions = [];
    if (portfolios.some(({ ownerDid }) => ownerDid)) {
        transactions.push(types_1.TxTags.portfolio.CreateCustodyPortfolio);
    }
    if (portfolios.some(({ ownerDid }) => !ownerDid)) {
        transactions.push(types_1.TxTags.portfolio.CreatePortfolio);
    }
    return {
        permissions: {
            transactions,
            assets: [],
            portfolios: [],
        },
    };
}
exports.getAuthorization = getAuthorization;
/**
 * @hidden
 */
const createPortfolios = () => new internal_1.Procedure(prepareCreatePortfolios, getAuthorization);
exports.createPortfolios = createPortfolios;
//# sourceMappingURL=createPortfolios.js.map