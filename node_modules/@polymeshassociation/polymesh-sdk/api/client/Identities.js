"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Identities = void 0;
const Venue_1 = require("../entities/Venue");
const internal_1 = require("../../internal");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * Handles all Identity related functionality
 */
class Identities {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = context;
        this.registerIdentity = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.registerIdentity, args] }, context);
        this.attestPrimaryKeyRotation = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.attestPrimaryKeyRotation, args] }, context);
        this.rotatePrimaryKey = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.rotatePrimaryKey, args] }, context);
        this.rotatePrimaryKeyToSecondary = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.rotatePrimaryKeyToSecondary, args] }, context);
        this.createPortfolio = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.createPortfolios,
                {
                    portfolios: [{ name: args.name, ownerDid: args.ownerDid }],
                },
            ],
            transformer: Venue_1.createPortfolioTransformer,
        }, context);
        this.createPortfolios = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [
                internal_1.createPortfolios,
                { portfolios: args.names.map(name => ({ name, ownerDid: args.ownerDid })) },
            ],
        }, context);
        this.createChild = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: args => [internal_1.createChildIdentity, args],
        }, context);
        this.allowIdentityToCreatePortfolios = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.allowIdentityToCreatePortfolios, args] }, context);
        this.revokeIdentityToCreatePortfolios = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.revokeIdentityToCreatePortfolios, args] }, context);
    }
    /**
     * Create an Identity instance from a DID
     *
     * @throws if there is no Identity with the passed DID
     */
    getIdentity(args) {
        return this.context.getIdentity(args.did);
    }
    /**
     * Create a ChildIdentity instance from a DID
     *
     * @throws if there is no ChildIdentity with the passed DID
     */
    getChildIdentity(args) {
        return this.context.getChildIdentity(args.did);
    }
    /**
     * Return whether the supplied Identity/DID exists
     */
    isIdentityValid(args) {
        return (0, internal_2.asIdentity)(args.identity, this.context).exists();
    }
    /**
     * Returns a list of allowed custodian did(s) for Identity
     * @throws if
     * - the provided Identity does not exist
     */
    getAllowedCustodians(did) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query }, }, } = this;
            const identity = (0, internal_2.asIdentity)(did, this.context);
            yield (0, internal_2.assertIdentityExists)(identity);
            const custodians = yield query.portfolio.allowedCustodians.entries(did.toString());
            return custodians.map(([storageKey]) => {
                const { args: [, custodianIdentityId], } = storageKey;
                return (0, conversion_1.identityIdToString)(custodianIdentityId);
            });
        });
    }
}
exports.Identities = Identities;
//# sourceMappingURL=Identities.js.map