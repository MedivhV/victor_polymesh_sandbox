"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Network = void 0;
const util_1 = require("@polkadot/util");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("../../base/utils");
const internal_1 = require("../../internal");
const queries_1 = require("../../middleware/queries");
const types_1 = require("../../types");
const constants_1 = require("../../utils/constants");
const conversion_1 = require("../../utils/conversion");
const internal_2 = require("../../utils/internal");
/**
 * Handles all Network related functionality, including querying for historical events from middleware
 */
class Network {
    /**
     * @hidden
     */
    constructor(context) {
        this.context = context;
        this.transferPolyx = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.transferPolyx, args] }, context);
    }
    /**
     * Retrieve the number of the latest finalized block in the chain
     */
    getLatestBlock() {
        return this.context.getLatestBlock();
    }
    /**
     * Fetch the current network version (e.g. 3.1.0)
     */
    getVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.getNetworkVersion();
        });
    }
    /**
     * Retrieve the chain's SS58 format
     */
    getSs58Format() {
        return this.context.ss58Format;
    }
    /**
     * Retrieve information for the current network
     */
    getNetworkProperties() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { runtimeVersion: { specVersion }, rpc: { system: { chain }, }, }, }, } = this;
            const name = yield chain();
            return {
                name: (0, conversion_1.textToString)(name),
                version: (0, conversion_1.u32ToBigNumber)(specVersion),
            };
        });
    }
    /**
     * Retrieve the protocol fees associated with running specific transactions
     *
     * @param args.tags - list of transaction tags (e.g. [TxTags.asset.CreateAsset, TxTags.asset.RegisterTicker] or ["asset.createAsset", "asset.registerTicker"])
     */
    getProtocolFees(args) {
        return this.context.getProtocolFees(args);
    }
    /**
     * Get the treasury wallet address
     */
    getTreasuryAccount() {
        const { context } = this;
        return new internal_1.Account({ address: (0, conversion_1.moduleAddressToString)(constants_1.TREASURY_MODULE_ADDRESS, context) }, context);
    }
    // eslint-disable-next-line require-jsdoc
    getTreasuryBalance(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = this.getTreasuryAccount();
            if (callback) {
                this.context.assertSupportsSubscription();
                return account.getBalance(({ free: freeBalance }) => {
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises -- callback errors should be handled by the caller
                    callback(freeBalance);
                });
            }
            const { free } = yield account.getBalance();
            return free;
        });
    }
    /**
     * Retrieve a single event by any of its indexed arguments. Can be filtered using parameters
     *
     * @param opts.moduleId - type of the module to fetch
     * @param opts.eventId - type of the event to fetch
     * @param opts.eventArg0 - event parameter value to filter by in position 0
     * @param opts.eventArg1 - event parameter value to filter by in position 1
     * @param opts.eventArg2 - event parameter value to filter by in position 2
     *
     * @note uses the middlewareV2
     */
    getEventByIndexedArgs(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { moduleId, eventId, eventArg0, eventArg1, eventArg2 } = opts;
            const { data: { events: { nodes: [event], }, }, } = yield context.queryMiddleware((0, queries_1.eventsByArgs)({
                moduleId,
                eventId,
                eventArg0,
                eventArg1,
                eventArg2,
            }, new bignumber_js_1.default(1)));
            return (0, internal_2.optionize)(conversion_1.middlewareEventDetailsToEventIdentifier)(event === null || event === void 0 ? void 0 : event.block, event === null || event === void 0 ? void 0 : event.eventIdx);
        });
    }
    /**
     * Submits a transaction payload with its signature to the chain. `signature` should be hex encoded
     *
     * @throws if the signature is not hex encoded
     */
    submitTransaction(txPayload, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { method, payload } = txPayload;
            const transaction = context.polymeshApi.tx(method);
            if (!signature.startsWith('0x')) {
                signature = `0x${signature}`;
            }
            if (!(0, util_1.isHex)(signature))
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.ValidationError,
                    message: '`signature` should be a hex encoded string',
                    data: { signature },
                });
            transaction.addSignature(payload.address, signature, payload);
            if (context.supportsSubscription()) {
                const submissionDetails = {
                    blockHash: '',
                    transactionHash: transaction.hash.toString(),
                    transactionIndex: new bignumber_js_1.default(0),
                };
                return new Promise((resolve, reject) => {
                    const gettingUnsub = transaction.send(receipt => {
                        const { status } = receipt;
                        let isLastCallback = false;
                        let unsubscribing = Promise.resolve();
                        let extrinsicFailedEvent;
                        // isCompleted implies status is one of: isFinalized, isInBlock or isError
                        if (receipt.isCompleted) {
                            if (receipt.isInBlock) {
                                const inBlockHash = status.asInBlock;
                                submissionDetails.blockHash = (0, conversion_1.hashToString)(inBlockHash);
                                // we know that the index has to be set by the time the transaction is included in a block
                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                submissionDetails.transactionIndex = new bignumber_js_1.default(receipt.txIndex);
                                // if the extrinsic failed due to an on-chain error, we should handle it in a special way
                                [extrinsicFailedEvent] = (0, internal_2.filterEventRecords)(receipt, 'system', 'ExtrinsicFailed', true);
                                // extrinsic failed so we can unsubscribe
                                isLastCallback = !!extrinsicFailedEvent;
                            }
                            else {
                                // isFinalized || isError so we know we can unsubscribe
                                isLastCallback = true;
                            }
                            if (isLastCallback) {
                                unsubscribing = gettingUnsub.then(unsub => {
                                    unsub();
                                });
                            }
                            /*
                             * Promise chain that handles all sub-promises in this pass through the signAndSend callback.
                             * Primarily for consistent error handling
                             */
                            let finishing = Promise.resolve();
                            if (extrinsicFailedEvent) {
                                const { data } = extrinsicFailedEvent;
                                finishing = Promise.all([unsubscribing]).then(() => {
                                    const error = (0, utils_1.handleExtrinsicFailure)(data[0]);
                                    reject(error);
                                });
                            }
                            else if (receipt.isFinalized) {
                                finishing = Promise.all([unsubscribing]).then(() => {
                                    resolve(submissionDetails);
                                });
                            }
                            else if (receipt.isError) {
                                reject(new internal_1.PolymeshError({ code: types_1.ErrorCode.TransactionAborted }));
                            }
                            finishing.catch((err) => reject(err));
                        }
                    });
                });
            }
            else {
                const startingBlock = yield context.getLatestBlock();
                yield transaction.send();
                const result = yield (0, utils_1.pollForTransactionFinalization)(transaction.hash, startingBlock, context);
                return {
                    blockHash: (0, conversion_1.hashToString)(result.status.asFinalized),
                    transactionHash: (0, conversion_1.hashToString)(transaction.hash),
                    transactionIndex: new bignumber_js_1.default(result.txIndex),
                };
            }
        });
    }
    /**
     * Retrieve a list of events. Can be filtered using parameters
     *
     * @param opts.moduleId - type of the module to fetch
     * @param opts.eventId - type of the event to fetch
     * @param opts.eventArg0 - event parameter value to filter by in position 0
     * @param opts.eventArg1 - event parameter value to filter by in position 1
     * @param opts.eventArg2 - event parameter value to filter by in position 2
     * @param opts.size - page size
     * @param opts.start - page offset
     *
     * @note uses the middlewareV2
     */
    getEventsByIndexedArgs(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const { moduleId, eventId, eventArg0, eventArg1, eventArg2, size, start } = opts;
            const { data: { events: { nodes: events }, }, } = yield context.queryMiddleware((0, queries_1.eventsByArgs)({
                moduleId,
                eventId,
                eventArg0,
                eventArg1,
                eventArg2,
            }, size, start));
            if (events.length) {
                return events.map(({ block, eventIdx }) => 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                (0, conversion_1.middlewareEventDetailsToEventIdentifier)(block, eventIdx));
            }
            return null;
        });
    }
    /**
     * Retrieve a transaction by hash
     *
     * @param opts.txHash - hash of the transaction
     *
     * @note uses the middlewareV2
     */
    getTransactionByHash(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { rpc: { chain: { getBlock }, }, call, }, }, context, } = this;
            const { data: { extrinsics: { nodes: [transaction], }, }, } = yield context.queryMiddleware((0, queries_1.extrinsicByHash)({
                extrinsicHash: opts.txHash,
            }));
            if (transaction) {
                const { extrinsicIdx, address: rawAddress, nonce, moduleId, callId, paramsTxt, success: txSuccess, specVersionId, extrinsicHash, block, } = transaction;
                const txTag = (0, conversion_1.extrinsicIdentifierToTxTag)({
                    moduleId,
                    callId,
                });
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const { hash: blockHash, blockId: blockNumber, datetime } = block;
                const rawBlockHash = (0, conversion_1.stringToBlockHash)(blockHash, context);
                const { block: { extrinsics: blockExtrinsics }, } = yield getBlock(rawBlockHash);
                const [{ partialFee }, [{ fees: protocol }]] = yield Promise.all([
                    call.transactionPaymentApi.queryInfo(blockExtrinsics[extrinsicIdx].toHex(), rawBlockHash),
                    context.getProtocolFees({ tags: [txTag], blockHash }),
                ]);
                const gas = (0, conversion_1.balanceToBigNumber)(partialFee);
                return {
                    blockNumber: new bignumber_js_1.default(blockNumber),
                    blockHash,
                    blockDate: new Date(`${datetime}Z`),
                    extrinsicIdx: new bignumber_js_1.default(extrinsicIdx),
                    address: rawAddress !== null && rawAddress !== void 0 ? rawAddress : null,
                    nonce: nonce ? new bignumber_js_1.default(nonce) : null,
                    txTag,
                    params: JSON.parse(paramsTxt),
                    success: !!txSuccess,
                    specVersionId: new bignumber_js_1.default(specVersionId),
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    extrinsicHash: extrinsicHash,
                    fee: {
                        gas,
                        protocol,
                        total: gas.plus(protocol),
                    },
                };
            }
            return null;
        });
    }
    /**
     * Retrieve middleware metadata.
     * Returns null if middleware is disabled
     *
     * @note uses the middleware V2
     */
    getMiddlewareMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.context.getMiddlewareMetadata();
        });
    }
    /**
     * Get the number of blocks the middleware needs to process to be synced with chain.
     * The lag can be around somewhere upto 15 blocks, but this can increase if the block size being processed by the Middleware is too large.
     * If the lag is too large, its recommended to check the indexer health to make sure the Middleware is processing the blocks.
     *
     * @note uses the middleware V2
     */
    getMiddlewareLag() {
        return __awaiter(this, void 0, void 0, function* () {
            let lastProcessedBlockFromMiddleware = new bignumber_js_1.default(0);
            const [latestBlockFromChain, middlewareMetadata] = yield Promise.all([
                this.context.getLatestBlock(),
                this.context.getMiddlewareMetadata(),
            ]);
            if (middlewareMetadata) {
                lastProcessedBlockFromMiddleware = middlewareMetadata.lastProcessedHeight;
            }
            return latestBlockFromChain.minus(lastProcessedBlockFromMiddleware);
        });
    }
    /**
     * Returns whether or not the connected chain node as support for confidential assets
     */
    supportsConfidentialAssets() {
        const { context: { polymeshApi: { query }, }, } = this;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return !!query.confidentialAsset;
    }
    /**
     * Returns if functions can be subscribed.
     *
     * @return `true` if connected over ws(s)://, otherwise `false`
     */
    supportsSubscription() {
        const { context } = this;
        return context.supportsSubscription();
    }
}
exports.Network = Network;
//# sourceMappingURL=Network.js.map