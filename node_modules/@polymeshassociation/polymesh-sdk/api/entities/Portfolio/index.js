"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Portfolio = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const lodash_1 = require("lodash");
const internal_1 = require("../../../internal");
const queries_1 = require("../../../middleware/queries");
const types_1 = require("../../../types");
const conversion_1 = require("../../../utils/conversion");
const internal_2 = require("../../../utils/internal");
const notExistsMessage = "The Portfolio doesn't exist or was removed by its owner";
/**
 * Represents a base Portfolio for a specific Identity in the Polymesh blockchain
 */
class Portfolio extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { did, id } = identifiers;
        this.owner = new internal_1.Identity({ did }, context);
        this._id = id;
        this.setCustodian = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.setCustodian, Object.assign(Object.assign({}, args), { did, id })] }, context);
        this.moveFunds = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.moveFunds, Object.assign(Object.assign({}, args), { from: this })] }, context);
        this.quitCustody = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: () => [internal_1.quitCustody, { portfolio: this }], voidArgs: true }, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { did, id } = identifier;
        return typeof did === 'string' && (id === undefined || id instanceof bignumber_js_1.default);
    }
    /**
     * Return whether an Identity is the Portfolio owner
     *
     * @param args.identity - defaults to the signing Identity
     */
    isOwnedBy(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { owner, context } = this;
            const identity = yield (0, internal_2.getIdentity)(args === null || args === void 0 ? void 0 : args.identity, context);
            return owner.isEqual(identity);
        });
    }
    /**
     * Return whether an Identity is the Portfolio custodian
     *
     * @param args.identity - optional, defaults to the signing Identity
     */
    isCustodiedBy(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const [portfolioCustodian, targetIdentity] = yield Promise.all([
                this.getCustodian(),
                (0, internal_2.getIdentity)(args === null || args === void 0 ? void 0 : args.identity, context),
            ]);
            return portfolioCustodian.isEqual(targetIdentity);
        });
    }
    /**
     * Retrieve the balances of all fungible assets in this Portfolio
     *
     * @param args.assets - array of FungibleAssets (or tickers) for which to fetch balances (optional, all balances are retrieved if not passed)
     */
    getAssetBalances(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { owner: { did }, _id: portfolioId, context: { polymeshApi: { query: { portfolio }, }, }, context, } = this;
            const rawPortfolioId = (0, conversion_1.portfolioIdToMeshPortfolioId)({ did, number: portfolioId }, context);
            const [exists, totalBalanceEntries, lockedBalanceEntries] = yield Promise.all([
                this.exists(),
                portfolio.portfolioAssetBalances.entries(rawPortfolioId),
                portfolio.portfolioLockedAssets.entries(rawPortfolioId),
            ]);
            if (!exists) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: notExistsMessage,
                });
            }
            const assetBalances = {};
            totalBalanceEntries.forEach(([key, balance]) => {
                const ticker = (0, conversion_1.tickerToString)(key.args[1]);
                const total = (0, conversion_1.balanceToBigNumber)(balance);
                assetBalances[ticker] = {
                    asset: new internal_1.FungibleAsset({ ticker }, context),
                    total,
                    locked: new bignumber_js_1.default(0),
                    free: total,
                };
            });
            lockedBalanceEntries.forEach(([key, balance]) => {
                const ticker = (0, conversion_1.tickerToString)(key.args[1]);
                const locked = (0, conversion_1.balanceToBigNumber)(balance);
                if (!locked.isZero()) {
                    const tickerBalance = assetBalances[ticker];
                    tickerBalance.locked = locked;
                    tickerBalance.free = assetBalances[ticker].total.minus(locked);
                }
            });
            const mask = args === null || args === void 0 ? void 0 : args.assets.map(asset => ({
                total: new bignumber_js_1.default(0),
                locked: new bignumber_js_1.default(0),
                free: new bignumber_js_1.default(0),
                asset: (0, internal_2.asFungibleAsset)(asset, context),
            }));
            if (mask) {
                return mask.map(portfolioBalance => {
                    var _a;
                    const { asset: { ticker }, } = portfolioBalance;
                    return (_a = assetBalances[ticker]) !== null && _a !== void 0 ? _a : portfolioBalance;
                });
            }
            return (0, lodash_1.values)(assetBalances);
        });
    }
    /**
     * Retrieve the NFTs held in this portfolio
     *
     *  @param args.assets - array of NftCollection (or tickers) for which to fetch holdings (optional, all holdings are retrieved if not passed)
     */
    getCollections(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { owner: { did }, _id: portfolioId, context: { polymeshApi: { query: { portfolio }, }, }, context, } = this;
            const rawPortfolioId = (0, conversion_1.portfolioIdToMeshPortfolioId)({ did, number: portfolioId }, context);
            const [exists, heldCollectionEntries, lockedCollectionEntries] = yield Promise.all([
                this.exists(),
                portfolio.portfolioNFT.entries(rawPortfolioId),
                portfolio.portfolioLockedNFT.entries(rawPortfolioId),
            ]);
            if (!exists) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: notExistsMessage,
                });
            }
            const queriedCollections = args === null || args === void 0 ? void 0 : args.collections.map(asset => (0, internal_2.asTicker)(asset));
            const seenTickers = new Set();
            const processCollectionEntry = (collectionRecord, entry) => {
                const [{ args: [, [rawTicker, rawNftId]], },] = entry;
                const ticker = (0, conversion_1.tickerToString)(rawTicker);
                const heldId = (0, conversion_1.u64ToBigNumber)(rawNftId);
                if (queriedCollections && !queriedCollections.includes(ticker)) {
                    return collectionRecord;
                }
                // if the user provided a filter arg, then ignore any asset not specified
                if (!queriedCollections || queriedCollections.includes(ticker)) {
                    seenTickers.add(ticker);
                    const nft = new internal_1.Nft({ id: heldId, ticker }, context);
                    if (!collectionRecord[ticker]) {
                        collectionRecord[ticker] = [nft];
                    }
                    else {
                        collectionRecord[ticker].push(nft);
                    }
                }
                return collectionRecord;
            };
            const heldCollections = heldCollectionEntries.reduce((collection, entry) => processCollectionEntry(collection, entry), {});
            const lockedCollections = lockedCollectionEntries.reduce((collection, entry) => processCollectionEntry(collection, entry), {});
            const collections = [];
            seenTickers.forEach(ticker => {
                const held = heldCollections[ticker];
                const locked = lockedCollections[ticker] || [];
                // calculate free NFTs by filtering held NFTs by locked NFT IDs
                const lockedIds = new Set(locked.map(({ id }) => id.toString()));
                const free = held.filter(({ id }) => !lockedIds.has(id.toString()));
                const total = new bignumber_js_1.default(held.length);
                collections.push({
                    collection: new internal_1.NftCollection({ ticker }, context),
                    free,
                    locked,
                    total,
                });
            });
            return collections;
        });
    }
    /**
     * Retrieve the custodian Identity of this Portfolio
     *
     * @note if no custodian is set, the owner Identity is returned
     */
    getCustodian() {
        return __awaiter(this, void 0, void 0, function* () {
            const { owner, owner: { did }, _id: portfolioId, context: { polymeshApi: { query: { portfolio }, }, }, context, } = this;
            const rawPortfolioId = (0, conversion_1.portfolioIdToMeshPortfolioId)({ did, number: portfolioId }, context);
            const [portfolioCustodian, exists] = yield Promise.all([
                portfolio.portfolioCustodian(rawPortfolioId),
                this.exists(),
            ]);
            if (!exists) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: notExistsMessage,
                });
            }
            try {
                const rawIdentityId = portfolioCustodian.unwrap();
                return new internal_1.Identity({ did: (0, conversion_1.identityIdToString)(rawIdentityId) }, context);
            }
            catch (_) {
                return owner;
            }
        });
    }
    /**
     * Retrieve a list of transactions where this portfolio was involved. Can be filtered using parameters
     *
     * @param filters.account - Account involved in the settlement
     * @param filters.ticker - ticker involved in the transaction
     *
     * @note uses the middlewareV2
     */
    getTransactionHistory(filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, owner: { did: identityId }, _id: portfolioId, } = this;
            const { account, ticker } = filters;
            const address = account ? (0, conversion_1.addressToKey)(account, context) : undefined;
            const settlementsPromise = context.queryMiddleware((0, queries_1.settlementsQuery)({
                identityId,
                portfolioId,
                address,
                ticker,
            }));
            const portfolioMovementsPromise = context.queryMiddleware((0, queries_1.portfolioMovementsQuery)({
                identityId,
                portfolioId,
                address,
                ticker,
            }));
            const [settlementsResult, portfolioMovementsResult, exists] = yield Promise.all([
                settlementsPromise,
                portfolioMovementsPromise,
                this.exists(),
            ]);
            if (!exists) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: notExistsMessage,
                });
            }
            const portfolioFilter = `${identityId}/${new bignumber_js_1.default(portfolioId || 0).toString()}`;
            return (0, conversion_1.toHistoricalSettlements)(settlementsResult, portfolioMovementsResult, portfolioFilter, context);
        });
    }
    /**
     * Return the Portfolio ID and owner DID
     */
    toHuman() {
        const { _id: id, owner: { did }, } = this;
        const result = {
            did,
        };
        return id ? (0, internal_2.toHumanReadable)(Object.assign(Object.assign({}, result), { id })) : result;
    }
}
exports.Portfolio = Portfolio;
//# sourceMappingURL=index.js.map