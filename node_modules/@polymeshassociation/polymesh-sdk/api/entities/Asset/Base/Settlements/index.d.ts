import BigNumber from 'bignumber.js';
import { BaseAsset, Context, FungibleAsset, Namespace, Nft } from "../../../../../internal";
import { NftCollection, NoArgsProcedureMethod, PortfolioLike, TransferBreakdown } from "../../../../../types";
/**
 * @hidden
 */
declare class BaseSettlements<T extends BaseAsset> extends Namespace<T> {
    /**
     * Pre-approves receiving this asset for the signing identity. Receiving this asset in a settlement will not require manual affirmation
     */
    preApprove: NoArgsProcedureMethod<void>;
    /**
     * Removes pre-approval for this asset
     */
    removePreApproval: NoArgsProcedureMethod<void>;
    /**
     * @hidden
     */
    constructor(parent: T, context: Context);
    /**
     * Check whether it is possible to create a settlement instruction to transfer a certain amount of this asset between two Portfolios. Returns a breakdown of
     *   the transaction containing general errors (such as insufficient balance or invalid receiver), any broken transfer restrictions, and any compliance
     *   failures
     *
     * @note this takes locked tokens into account. For example, if portfolio A has 1000 tokens and this function is called to check if 700 of them can be
     *   transferred to portfolio B (assuming everything else checks out) the result will be success. If an instruction is created and authorized to transfer those 700 tokens,
     *   they would become locked. From that point, further calls to this function would return failed results because of the funds being locked, even though they haven't been
     *   transferred yet
     *
     * @param args.from - sender Portfolio (optional, defaults to the signing Identity's Default Portfolio)
     * @param args.to - receiver Portfolio
     * @param args.amount - amount of fungible tokens to transfer
     * @param args.nfts - the NFTs to transfer
     *
     */
    protected canTransferBase(args: {
        from?: PortfolioLike;
        to: PortfolioLike;
        amount: BigNumber;
    } | {
        from?: PortfolioLike;
        to: PortfolioLike;
        nfts: (Nft | BigNumber)[];
    }): Promise<TransferBreakdown>;
}
/**
 * Handles all Asset Settlements related functionality
 */
export declare class FungibleSettlements extends BaseSettlements<FungibleAsset> {
    /**
     * Check whether it is possible to create a settlement instruction to transfer a certain amount of this asset between two Portfolios. Returns a breakdown of
     *   the transaction containing general errors (such as insufficient balance or invalid receiver), any broken transfer restrictions, and any compliance
     *   failures
     *
     * @note this takes locked tokens into account. For example, if portfolio A has 1000 tokens and this function is called to check if 700 of them can be
     *   transferred to portfolio B (assuming everything else checks out) the result will be success. If an instruction is created and authorized to transfer those 700 tokens,
     *   they would become locked. From that point, further calls to this function would return failed results because of the funds being locked, even though they haven't been
     *   transferred yet
     *
     * @param args.from - sender Portfolio (optional, defaults to the signing Identity's Default Portfolio)
     * @param args.to - receiver Portfolio
     * @param args.amount - amount of tokens to transfer
     *
     */
    canTransfer(args: {
        from?: PortfolioLike;
        to: PortfolioLike;
        amount: BigNumber;
    }): Promise<TransferBreakdown>;
}
/**
 * Handles all Asset Settlements related functionality
 */
export declare class NonFungibleSettlements extends BaseSettlements<NftCollection> {
    /**
     * Check whether it is possible to create a settlement instruction to transfer an NFT between two Portfolios. Returns a breakdown of
     *   the transaction containing general errors (such as insufficient balance or invalid receiver), any broken transfer restrictions, and any compliance
     *   failures
     *
     * @note this takes locked tokens into account. For example, if portfolio A has NFTs 1, 2 and 3 of a collection and this function is called to check if 1 of them can be
     *   transferred to portfolio B (assuming everything else checks out) the result will be success. If an instruction is created and authorized to transfer that token,
     *   they would become locked. From that point, further calls to this function would return failed results because of the funds being locked, even though it hasn't been
     *   transferred yet
     *
     * @param args.from - sender Portfolio (optional, defaults to the signing Identity's Default Portfolio)
     * @param args.to - receiver Portfolio
     * @param args.nfts - the NFTs to transfer
     *
     */
    canTransfer(args: {
        from?: PortfolioLike;
        to: PortfolioLike;
        nfts: (BigNumber | Nft)[];
    }): Promise<TransferBreakdown>;
}
export {};
//# sourceMappingURL=index.d.ts.map