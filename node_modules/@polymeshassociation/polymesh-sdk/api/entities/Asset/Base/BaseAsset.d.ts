import { Compliance } from "./Compliance";
import { Documents } from "./Documents";
import { Metadata } from "./Metadata";
import { Permissions } from "./Permissions";
import { Context, Entity, Identity } from "../../../../internal";
import { Asset, AssetDetails, AssetMediatorParams, AuthorizationRequest, ModifyAssetParams, NoArgsProcedureMethod, ProcedureMethod, SecurityIdentifier, SetVenueFilteringParams, SubCallback, TransferAssetOwnershipParams, UniqueIdentifiers, UnsubCallback, VenueFilteringDetails } from "../../../../types";
/**
 * Class used to manage functionality common to all assets.
 *
 */
export declare class BaseAsset extends Entity<UniqueIdentifiers, string> {
    compliance: Compliance;
    documents: Documents;
    metadata: Metadata;
    permissions: Permissions;
    /**
     * Identity ID of the Asset (used for Claims)
     */
    did: string;
    /**
     * ticker of the Asset
     */
    ticker: string;
    /**
     * Transfer ownership of the Asset to another Identity. This generates an authorization request that must be accepted
     *   by the recipient
     *
     * @note this will create {@link api/entities/AuthorizationRequest!AuthorizationRequest | Authorization Request} which has to be accepted by the `target` Identity.
     *   An {@link api/entities/Account!Account} or {@link api/entities/Identity!Identity} can fetch its pending Authorization Requests by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getReceived | authorizations.getReceived}.
     *   Also, an Account or Identity can directly fetch the details of an Authorization Request by calling {@link api/entities/common/namespaces/Authorizations!Authorizations.getOne | authorizations.getOne}
     */
    transferOwnership: ProcedureMethod<TransferAssetOwnershipParams, AuthorizationRequest>;
    /**
     * Enable/disable venue filtering for this Asset and/or set allowed/disallowed venues
     */
    setVenueFiltering: ProcedureMethod<SetVenueFilteringParams, void>;
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier: unknown): identifier is UniqueIdentifiers;
    /**
     * Modify some properties of the Asset
     *
     * @throws if the passed values result in no changes being made to the Asset
     */
    modify: ProcedureMethod<ModifyAssetParams, Asset>;
    /**
     * @hidden
     *
     * @note It is generally preferable to instantiate `FungibleAsset` or `NftCollection`
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Freeze transfers of the Asset
     */
    freeze: NoArgsProcedureMethod<void>;
    /**
     * Unfreeze transfers of the Asset
     */
    unfreeze: NoArgsProcedureMethod<void>;
    /**
     * Add required mediators. Mediators must approve any trades involving the asset
     */
    addRequiredMediators: ProcedureMethod<AssetMediatorParams, void>;
    /**
     * Remove required mediators
     */
    removeRequiredMediators: ProcedureMethod<AssetMediatorParams, void>;
    /**
     * Retrieve the Asset's identifiers list
     *
     * @note can be subscribed to, if connected to node using a web socket
     */
    getIdentifiers(): Promise<SecurityIdentifier[]>;
    getIdentifiers(callback?: SubCallback<SecurityIdentifier[]>): Promise<UnsubCallback>;
    /**
     * Check whether transfers are frozen for the Asset
     *
     * @note can be subscribed to, if connected to node using a web socket
     */
    isFrozen(): Promise<boolean>;
    isFrozen(callback: SubCallback<boolean>): Promise<UnsubCallback>;
    /**
     * Retrieve the Asset's data
     *
     * @note can be subscribed to, if connected to node using a web socket
     */
    details(): Promise<AssetDetails>;
    details(callback: SubCallback<AssetDetails>): Promise<UnsubCallback>;
    /**
     * Get required Asset mediators. These Identities must approve any Instruction involving the asset
     */
    getRequiredMediators(): Promise<Identity[]>;
    /**
     * Get venue filtering details
     */
    getVenueFilteringDetails(): Promise<VenueFilteringDetails>;
    /**
     * Retrieve the Asset's funding round
     *
     * @note can be subscribed to, if connected to node using a web socket
     */
    currentFundingRound(): Promise<string | null>;
    currentFundingRound(callback: SubCallback<string | null>): Promise<UnsubCallback>;
    /**
     * @hidden
     */
    exists(): Promise<boolean>;
    /**
     * Return the NftCollection's ticker
     */
    toHuman(): string;
}
//# sourceMappingURL=BaseAsset.d.ts.map