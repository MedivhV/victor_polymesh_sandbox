import BigNumber from 'bignumber.js';
import { BaseAsset } from "../Base";
import { NonFungibleSettlements } from "../Base/Settlements";
import { AssetHolders } from "./AssetHolders";
import { Context, Nft } from "../../../../internal";
import { AssetDetails, CollectionKey, EventIdentifier, HistoricNftTransaction, IssueNftParams, NftControllerTransferParams, ProcedureMethod, ResultSet, SubCallback, UniqueIdentifiers, UnsubCallback } from "../../../../types";
/**
 * Class used to manage NFT functionality
 */
export declare class NftCollection extends BaseAsset {
    assetHolders: AssetHolders;
    settlements: NonFungibleSettlements;
    /**
     * Issues a new NFT for the collection
     *
     * @note Each NFT requires metadata for each value returned by `collectionKeys`. The SDK and chain only validate the presence of these fields. Additional validation may be needed to ensure each value complies with the specification.
     */
    issue: ProcedureMethod<IssueNftParams, Nft>;
    /**
     * Force a transfer from the origin portfolio to one of the caller's portfolios
     */
    controllerTransfer: ProcedureMethod<NftControllerTransferParams, void>;
    /**
     * Local cache for `getCollectionId`
     *
     * @hidden
     */
    private _id?;
    /**
     * @hidden
     */
    constructor(identifiers: UniqueIdentifiers, context: Context);
    /**
     * Retrieve the NftCollection's data
     *
     * @note can be subscribed to, if connected to node using a web socket
     */
    details(): Promise<AssetDetails>;
    details(callback: SubCallback<AssetDetails>): Promise<UnsubCallback>;
    /**
     * Retrieve the metadata that defines the NFT collection. Every `issue` call for this collection must provide a value for each element returned
     *
     * @note Each NFT **must** have an entry for each value, it **should** comply with the spec.
     * In other words, the SDK only validates the presence of metadata keys, additional validation should be used when issuing
     */
    collectionKeys(): Promise<CollectionKey[]>;
    /**
     * Retrieve the amount of unique investors that hold this Nft
     */
    investorCount(): Promise<BigNumber>;
    /**
     * Get an NFT belonging to this collection
     *
     * @throws if the given NFT does not exist
     */
    getNft(args: {
        id: BigNumber;
    }): Promise<Nft>;
    /**
     * Retrieve the identifier data (block number, date and event index) of the event that was emitted when the token was created
     *
     * @note uses the middlewareV2
     * @note there is a possibility that the data is not ready by the time it is requested. In that case, `null` is returned
     */
    createdAt(): Promise<EventIdentifier | null>;
    /**
     * Determine whether this NftCollection exists on chain
     */
    exists(): Promise<boolean>;
    /**
     * Returns the collection's on chain numeric ID. Used primarily to access NFT specific storage values
     */
    getCollectionId(): Promise<BigNumber>;
    /**
     * Retrieve this Collection's transaction history
     *
     * @note uses the middlewareV2
     */
    getTransactionHistory(opts: {
        size?: BigNumber;
        start?: BigNumber;
    }): Promise<ResultSet<HistoricNftTransaction>>;
}
//# sourceMappingURL=NftCollection.d.ts.map