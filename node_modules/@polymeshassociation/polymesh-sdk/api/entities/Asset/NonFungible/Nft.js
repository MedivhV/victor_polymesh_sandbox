"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Nft = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const internal_1 = require("../../../../internal");
const types_1 = require("../../../../types");
const constants_1 = require("../../../../utils/constants");
const conversion_1 = require("../../../../utils/conversion");
const internal_2 = require("../../../../utils/internal");
/**
 * Class used to manage Nft functionality. Each NFT belongs to an NftCollection, which specifies the expected metadata values for each NFT
 */
class Nft extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { ticker, id } = identifiers;
        this.id = id;
        this.collection = new internal_1.NftCollection({ ticker }, context);
        this.redeem = (0, internal_2.createProcedureMethod)({ getProcedureAndArgs: args => [internal_1.redeemNft, Object.assign({ ticker, id }, args)], optionalArgs: true }, context);
    }
    /**
     * @hidden
     * Check if a value is of type {@link UniqueIdentifiers}
     */
    static isUniqueIdentifiers(identifier) {
        const { ticker, id } = identifier;
        return typeof ticker === 'string' && id instanceof bignumber_js_1.default;
    }
    /**
     * Get metadata associated with this token
     */
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            const { id, context, collection, context: { polymeshApi: { query }, }, } = this;
            const collectionId = yield collection.getCollectionId();
            const rawCollectionId = (0, conversion_1.bigNumberToU64)(collectionId, context);
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const entries = yield query.nft.metadataValue.entries([rawCollectionId, rawId]);
            return entries.map(([storageKey, rawValue]) => {
                const rawMetadataKey = storageKey.args[1];
                const key = (0, conversion_1.meshMetadataKeyToMetadataKey)(rawMetadataKey, collection.ticker);
                const value = (0, conversion_1.bytesToString)(rawValue);
                return { key, value };
            });
        });
    }
    /**
     * Determine if the NFT exists on chain
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = yield this.getOwner();
            return owner !== null;
        });
    }
    /**
     * Get the conventional image URI for the NFT
     *
     * This function will check for a token level value and a collection level value. Token level values take precedence over base values in case of a conflict.
     *
     * When creating a collection an issuer can either require per token images by specifying global metadata key `imageUri` as a collection key or by
     * setting a collection base image URL by setting a value on the collection corresponding to the global metadata key `baseImageUri`.
     *
     * This method will return `null` if the NFT issuer did not configure the collection according to the convention.
     *
     * Per token URIs provide the most flexibility, but require more chain space to store, increasing the POLYX fee to issue each token.
     *
     * The URI values can include `{tokenId}` that will be replaced with the NFTs ID. If a base URI does not specify this the ID will be appended onto the URL. Examples:
     *  - `https://example.com/nfts/{tokenId}/image.png` becomes `https://example.com/nfts/1/image.png`
     *  - `https://example.com/nfts` becomes `https://example.com/nfts/1` if used a base value, but remain unchanged as a local value
     */
    getImageUri() {
        return __awaiter(this, void 0, void 0, function* () {
            const [localId, collectionId] = yield Promise.all([
                this.getGlobalMetadataId(constants_1.GLOBAL_IMAGE_URI_NAME),
                this.getGlobalMetadataId(constants_1.GLOBAL_BASE_IMAGE_URI_NAME),
            ]);
            const [localImageUrl, collectionBaseImageUrl] = yield Promise.all([
                this.getLocalUri(localId),
                this.getBaseUri(collectionId),
            ]);
            if (localImageUrl) {
                return localImageUrl;
            }
            else if (collectionBaseImageUrl) {
                return collectionBaseImageUrl;
            }
            return null;
        });
    }
    /**
     * Get the conventional token URI for the NFT
     *
     * This function will check for a token level value and a collection level value. Token level values take precedence over base values in case of a conflict.
     *
     * When creating a collection an issuer can either require per token URL by specifying global metadata key `tokenURI` as a collection key or by
     * setting a collection base URL by setting a value on the collection corresponding to the global metadata key `baseTokenUri` on the collection.
     *
     * This method will return `null` if the NFT issuer did not configure the collection according to the convention.
     *
     * Per token URIs provide the most flexibility, but require more chain space to store, increasing the POLYX fee to issue each token.
     *
     * The URI values can include `{tokenId}` that will be replaced with the NFTs ID. If a base URI does not specify this the ID will be appended onto the URL. Examples:
     *  - `https://example.com/nfts/{tokenId}/info.json` becomes `https://example.com/nfts/1/info.json`
     *  - `https://example.com/nfts` becomes `https://example.com/nfts/1` if used a base value, but remain unchanged as a local value
     */
    getTokenUri() {
        return __awaiter(this, void 0, void 0, function* () {
            const [localId, baseId] = yield Promise.all([
                this.getGlobalMetadataId(constants_1.GLOBAL_TOKEN_URI_NAME),
                this.getGlobalMetadataId(constants_1.GLOBAL_BASE_TOKEN_URI_NAME),
            ]);
            const [localTokenUri, baseUri] = yield Promise.all([
                this.getLocalUri(localId),
                this.getBaseUri(baseId),
            ]);
            if (localTokenUri) {
                return localTokenUri;
            }
            else if (baseUri) {
                return baseUri;
            }
            return null;
        });
    }
    /**
     * Get owner of the NFT
     *
     * @note This method returns `null` if there is no existing holder for the token. This may happen even if the token has been redeemed/burned
     */
    getOwner() {
        return __awaiter(this, void 0, void 0, function* () {
            const { collection: { ticker }, id, context: { polymeshApi: { query: { nft: { nftOwner }, }, }, }, context, } = this;
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const rawNftId = (0, conversion_1.bigNumberToU64)(id, context);
            const owner = yield nftOwner(rawTicker, rawNftId);
            if (owner.isEmpty) {
                return null;
            }
            return (0, conversion_1.meshPortfolioIdToPortfolio)(owner.unwrap(), context);
        });
    }
    /**
     * Check if the NFT is locked in any settlement instruction
     *
     * @throws if NFT has no owner (has been redeemed)
     */
    isLocked() {
        return __awaiter(this, void 0, void 0, function* () {
            const { collection: { ticker }, id, context: { polymeshApi: { query: { portfolio }, }, }, context, } = this;
            const owner = yield this.getOwner();
            if (!owner) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: 'NFT does not exists. The token may have been redeemed',
                });
            }
            const rawLocked = yield portfolio.portfolioLockedNFT((0, conversion_1.portfolioToPortfolioId)(owner), [
                (0, conversion_1.stringToTicker)(ticker, context),
                (0, conversion_1.bigNumberToU64)(id, context),
            ]);
            return (0, conversion_1.boolToBoolean)(rawLocked);
        });
    }
    /**
     * @hidden
     */
    toHuman() {
        const { collection: { ticker }, id, } = this;
        return {
            collection: ticker,
            id: id.toString(),
        };
    }
    /**
     * given a global metadata ID fetches a local URI value
     *
     * @hidden
     */
    getLocalUri(metadataId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id, context, collection, context: { polymeshApi: { query }, }, } = this;
            if (!metadataId) {
                return null;
            }
            const collectionId = yield collection.getCollectionId();
            const rawCollectionId = (0, conversion_1.bigNumberToU64)(collectionId, context);
            const rawNftId = (0, conversion_1.bigNumberToU64)(id, context);
            const rawNftValue = yield query.nft.metadataValue([rawCollectionId, rawNftId], {
                Global: (0, conversion_1.bigNumberToU64)(metadataId, context),
            });
            const nftValue = (0, conversion_1.bytesToString)(rawNftValue);
            if (nftValue === '') {
                return null;
            }
            return this.templateId(nftValue);
        });
    }
    /**
     *
     * given a global metadata ID fetches a base URI value
     *
     * @hidden
     */
    getBaseUri(metadataId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { collection: { ticker }, context, context: { polymeshApi: { query }, }, } = this;
            if (!metadataId) {
                return null;
            }
            const rawId = (0, conversion_1.bigNumberToU64)(metadataId, context);
            const rawTicker = (0, conversion_1.stringToTicker)(ticker, context);
            const rawValue = yield query.asset.assetMetadataValues(rawTicker, { Global: rawId });
            if (rawValue.isNone) {
                return null;
            }
            const baseUrl = (0, conversion_1.bytesToString)(rawValue.unwrap());
            return this.templateBaseUri(baseUrl);
        });
    }
    /**
     * @hidden
     */
    templateId(input) {
        const { id } = this;
        return input.replace('{tokenId}', id.toString());
    }
    /**
     * @hidden
     */
    templateBaseUri(input) {
        const { id } = this;
        const templatedPath = this.templateId(input);
        if (input !== templatedPath) {
            return templatedPath;
        }
        else if (input.endsWith('/')) {
            return `${input}${id.toString()}`;
        }
        else {
            return `${input}/${id.toString()}`;
        }
    }
    /**
     * helper to lookup global metadata ID by name
     *
     * @hidden
     */
    getGlobalMetadataId(keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query }, }, } = this;
            const metadataId = yield query.asset.assetMetadataGlobalNameToKey(keyName);
            if (metadataId.isSome) {
                return (0, conversion_1.u64ToBigNumber)(metadataId.unwrap());
            }
            return null;
        });
    }
}
exports.Nft = Nft;
//# sourceMappingURL=Nft.js.map