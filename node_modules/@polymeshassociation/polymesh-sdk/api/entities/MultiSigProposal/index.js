"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSigProposal = void 0;
const internal_1 = require("../../../internal");
const queries_1 = require("../../../middleware/queries");
const types_1 = require("../../../types");
const conversion_1 = require("../../../utils/conversion");
const internal_2 = require("../../../utils/internal");
/**
 * A proposal for a MultiSig transaction. This is a wrapper around an extrinsic that will be executed when the amount of approvals reaches the signature threshold set on the MultiSig Account
 */
class MultiSigProposal extends internal_1.Entity {
    /**
     * @hidden
     */
    constructor(identifiers, context) {
        super(identifiers, context);
        const { multiSigAddress, id } = identifiers;
        (0, internal_2.assertAddressValid)(multiSigAddress, context.ss58Format);
        this.multiSig = new internal_1.MultiSig({ address: multiSigAddress }, context);
        this.id = id;
        this.approve = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [
                internal_1.evaluateMultiSigProposal,
                { proposal: this, action: types_1.MultiSigProposalAction.Approve },
            ],
            voidArgs: true,
        }, context);
        this.reject = (0, internal_2.createProcedureMethod)({
            getProcedureAndArgs: () => [
                internal_1.evaluateMultiSigProposal,
                { proposal: this, action: types_1.MultiSigProposalAction.Reject },
            ],
            voidArgs: true,
        }, context);
    }
    /**
     * Fetches the details of the Proposal. This includes the amount of approvals and rejections, the expiry, and details of the wrapped extrinsic
     */
    details() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { multiSig }, }, }, multiSig: { address: multiSigAddress }, id, context, } = this;
            const rawMultiSignAddress = (0, conversion_1.stringToAccountId)(multiSigAddress, context);
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const [{ approvals: rawApprovals, rejections: rawRejections, status: rawStatus, expiry: rawExpiry, autoClose: rawAutoClose, }, proposalOpt, votes,] = yield Promise.all([
                multiSig.proposalDetail(rawMultiSignAddress, rawId),
                multiSig.proposals(rawMultiSignAddress, rawId),
                multiSig.votes.entries([rawMultiSignAddress, rawId]),
            ]);
            if (proposalOpt.isNone) {
                throw new internal_1.PolymeshError({
                    code: types_1.ErrorCode.DataUnavailable,
                    message: `Proposal with ID: "${id}" was not found. It may have already been executed`,
                });
            }
            const proposal = proposalOpt.unwrap();
            const { method, section } = proposal;
            const { args } = proposal.toJSON();
            const approvalAmount = (0, conversion_1.u64ToBigNumber)(rawApprovals);
            const rejectionAmount = (0, conversion_1.u64ToBigNumber)(rawRejections);
            const expiry = (0, internal_2.optionize)(conversion_1.momentToDate)(rawExpiry.unwrapOr(null));
            const status = (0, conversion_1.meshProposalStatusToProposalStatus)(rawStatus, expiry);
            const autoClose = (0, conversion_1.boolToBoolean)(rawAutoClose);
            const voted = [];
            if (votes.length > 0) {
                votes.forEach(([voteStorageKey, didVote]) => {
                    if (didVote.isTrue && voteStorageKey.args[1].isAccount)
                        voted.push(new internal_1.Account({ address: (0, conversion_1.accountIdToString)(voteStorageKey.args[1].asAccount) }, context));
                });
            }
            return {
                approvalAmount,
                rejectionAmount,
                status,
                expiry,
                autoClose,
                args,
                txTag: `${section}.${method}`,
                voted,
            };
        });
    }
    /**
     * Determines whether this Proposal exists on chain
     */
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context: { polymeshApi: { query: { multiSig }, }, }, multiSig: { address: multiSigAddress }, id, context, } = this;
            const rawId = (0, conversion_1.bigNumberToU64)(id, context);
            const rawMultiSignAddress = (0, conversion_1.stringToAccountId)(multiSigAddress, context);
            const rawProposal = yield multiSig.proposals(rawMultiSignAddress, rawId);
            return rawProposal.isSome;
        });
    }
    /**
     * Returns a human readable representation
     */
    toHuman() {
        const { multiSig: { address: multiSigAddress }, id, } = this;
        return {
            multiSigAddress,
            id: id.toString(),
        };
    }
    /**
     * Fetches the individual votes for this MultiSig proposal and their identifier data (block number, date and event index) of the event that was emitted when this MultiSig Proposal Vote was casted
     *
     * @note uses the middlewareV2
     */
    votes() {
        return __awaiter(this, void 0, void 0, function* () {
            const { multiSig: { address }, id, context, } = this;
            const { data: { multiSigProposalVotes: { nodes: signerVotes }, }, } = yield context.queryMiddleware((0, queries_1.multiSigProposalVotesQuery)({
                proposalId: `${address}/${id.toString()}`,
            }));
            return signerVotes.map(signerVote => {
                const { signer, action, createdBlock, eventIdx } = signerVote;
                const { signerType, signerValue } = signer;
                return Object.assign({ signer: (0, conversion_1.signerValueToSigner)({ type: signerType, value: signerValue }, context), action: action }, (0, conversion_1.middlewareEventDetailsToEventIdentifier)(createdBlock, eventIdx));
            });
        });
    }
    /**
     * @hidden
     *
     * Queries the SQ to get MultiSig Proposal details
     */
    getProposalDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context, id, multiSig: { address }, } = this;
            const { data: { multiSigProposals: { nodes: [node], }, }, } = yield context.queryMiddleware((0, queries_1.multiSigProposalQuery)({
                multisigId: address,
                proposalId: id.toNumber(),
            }));
            return node;
        });
    }
    /**
     * Retrieve the identifier data (block number, date and event index) of the event that was emitted when this MultiSig Proposal was created
     *
     * @note uses the middlewareV2
     * @note there is a possibility that the data is not ready by the time it is requested. In that case, `null` is returned
     */
    createdAt() {
        return __awaiter(this, void 0, void 0, function* () {
            const proposal = yield this.getProposalDetails();
            return (0, internal_2.optionize)(conversion_1.middlewareEventDetailsToEventIdentifier)(proposal === null || proposal === void 0 ? void 0 : proposal.createdBlock, proposal === null || proposal === void 0 ? void 0 : proposal.eventIdx);
        });
    }
    /**
     * Retrieve the account which created this MultiSig Proposal
     *
     * @note uses the middlewareV2
     * @note there is a possibility that the data is not ready by the time it is requested. In that case, `null` is returned
     */
    creator() {
        return __awaiter(this, void 0, void 0, function* () {
            const { context } = this;
            const proposal = yield this.getProposalDetails();
            return (0, internal_2.optionize)(internal_2.asAccount)(proposal === null || proposal === void 0 ? void 0 : proposal.creatorAccount, context);
        });
    }
}
exports.MultiSigProposal = MultiSigProposal;
//# sourceMappingURL=index.js.map