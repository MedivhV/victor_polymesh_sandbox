"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pollForTransactionFinalization = exports.handleTransactionSubmissionError = exports.handleExtrinsicFailure = exports.processType = void 0;
const api_1 = require("@polkadot/api");
const types_1 = require("@polkadot/types");
const types_2 = require("@polkadot/types/types");
const definitions_1 = require("../polkadot/definitions");
const internal_1 = require("../internal");
const types_3 = require("../types");
const constants_1 = require("../utils/constants");
const conversion_1 = require("../utils/conversion");
const internal_2 = require("../utils/internal");
const { types } = definitions_1.polymesh;
const getRootType = (type) => {
    const rootType = constants_1.ROOT_TYPES[type];
    if (rootType) {
        return {
            type: rootType,
        };
    }
    if (type === 'Null') {
        return {
            type: types_3.TransactionArgumentType.Null,
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const definition = types[type];
    if (!definition) {
        return {
            type: types_3.TransactionArgumentType.Unknown,
        };
    }
    const typeDef = (0, types_1.getTypeDef)(JSON.stringify(definition));
    if (typeDef.info === types_2.TypeDefInfo.Plain) {
        return getRootType(definition);
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    return (0, exports.processType)(typeDef, '');
};
const processType = (rawType, name) => {
    const { type, info, sub } = rawType;
    const arg = {
        name,
        optional: false,
        _rawType: rawType,
    };
    switch (info) {
        case types_2.TypeDefInfo.Plain: {
            return Object.assign(Object.assign({}, getRootType(type)), arg);
        }
        case types_2.TypeDefInfo.Compact: {
            return Object.assign(Object.assign({}, (0, exports.processType)(sub, name)), arg);
        }
        case types_2.TypeDefInfo.Option: {
            return Object.assign(Object.assign(Object.assign({}, (0, exports.processType)(sub, name)), arg), { optional: true });
        }
        case types_2.TypeDefInfo.Tuple: {
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.Tuple }, arg), { internal: sub.map((def, index) => (0, exports.processType)(def, `${index}`)) });
        }
        case types_2.TypeDefInfo.Vec: {
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.Array }, arg), { internal: (0, exports.processType)(sub, '') });
        }
        case types_2.TypeDefInfo.VecFixed: {
            return Object.assign({ type: types_3.TransactionArgumentType.Text }, arg);
        }
        case types_2.TypeDefInfo.Enum: {
            const subTypes = sub;
            const isSimple = subTypes.every(({ type: subType }) => subType === 'Null');
            if (isSimple) {
                return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.SimpleEnum }, arg), { 
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    internal: subTypes.map(({ name: subName }) => subName) });
            }
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.RichEnum }, arg), { 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                internal: subTypes.map(def => (0, exports.processType)(def, def.name)) });
        }
        case types_2.TypeDefInfo.Struct: {
            return Object.assign(Object.assign({ type: types_3.TransactionArgumentType.Object }, arg), { 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                internal: sub.map(def => (0, exports.processType)(def, def.name)) });
        }
        default: {
            return Object.assign({ type: types_3.TransactionArgumentType.Unknown }, arg);
        }
    }
};
exports.processType = processType;
/**
 * @hidden
 */
const handleExtrinsicFailure = (error, data) => {
    // get revert message from event
    let message;
    if (error.isModule) {
        // known error
        const mod = error.asModule;
        const { section, name, docs } = mod.registry.findMetaError(mod);
        message = `${section}.${name}: ${docs.join(' ')}`;
    }
    else if (error.isBadOrigin) {
        message = 'Bad origin';
    }
    else if (error.isCannotLookup) {
        message = 'Could not lookup information required to validate the transaction';
    }
    else {
        message = 'Unknown error';
    }
    return new internal_1.PolymeshError({ code: types_3.ErrorCode.TransactionReverted, message, data });
};
exports.handleExtrinsicFailure = handleExtrinsicFailure;
const handleTransactionSubmissionError = (err) => {
    let error;
    /* istanbul ignore else */
    if (err.message.indexOf('Cancelled') > -1) {
        // tx rejected by signer
        error = { code: types_3.ErrorCode.TransactionRejectedByUser };
    }
    else {
        // unexpected error
        error = { code: types_3.ErrorCode.UnexpectedError, message: err.message };
    }
    return new internal_1.PolymeshError(error);
};
exports.handleTransactionSubmissionError = handleTransactionSubmissionError;
/**
 * @hidden
 *
 * given a transaction hash this will poll the chain until it is included in a finalized block
 *
 * @note this method should only be used when there is no subscription support for efficiency
 *
 * @throws if transaction is not found after a certain amount of time
 *
 * @param txHash The hash of the transaction
 * @param startingBlock The block number from before the transaction was submitted
 * @param context
 * @param pollOptions Controls max time to poll, defaults should be OK (finalization takes ~15 seconds)
 * @returns
 */
const pollForTransactionFinalization = (txHash, startingBlock, context, pollOptions = { delayMs: 3000, maxAttempts: 10 }) => __awaiter(void 0, void 0, void 0, function* () {
    let lastCheckedBlock = startingBlock;
    let locationInfo;
    let txIndex;
    // Finalization is expected to take ~15 seconds
    const { delayMs, maxAttempts } = pollOptions;
    let attemptCounter = 0;
    while (!locationInfo && attemptCounter < maxAttempts) {
        attemptCounter += 1;
        yield (0, internal_2.delay)(delayMs);
        const latestBlockNumber = yield context.getLatestBlock();
        if (!latestBlockNumber.eq(lastCheckedBlock)) {
            const blocksToCheck = [];
            const numberOfCandidateBlocks = latestBlockNumber.minus(lastCheckedBlock).toNumber();
            for (let i = 1; i <= numberOfCandidateBlocks; i++) {
                const blockNumber = lastCheckedBlock.plus(i);
                blocksToCheck.push((0, conversion_1.bigNumberToU32)(blockNumber, context));
            }
            const blockHashesToCheck = yield context.polymeshApi.query.system.blockHash.multi(blocksToCheck);
            const newBlocks = yield Promise.all(blockHashesToCheck.map(hash => context.polymeshApi.rpc.chain.getBlock(hash)));
            for (const newBlock of newBlocks) {
                txIndex = newBlock.block.extrinsics.findIndex(value => txHash.eq(value.hash));
                if (txIndex >= 0) {
                    locationInfo = { txIndex, block: newBlock };
                    break;
                }
            }
            lastCheckedBlock = latestBlockNumber;
        }
    }
    if (!locationInfo) {
        throw new internal_1.PolymeshError({
            code: types_3.ErrorCode.UnexpectedError,
            message: 'The block containing the transaction was not found',
        });
    }
    const queryAt = yield context.polymeshApi.at(locationInfo.block.block.header.hash);
    const allEvents = yield queryAt.query.system.events();
    const relatedEvents = allEvents.filter(event => {
        if (event.phase.isApplyExtrinsic) {
            return event.phase.asApplyExtrinsic.eq(locationInfo.txIndex);
        }
        return false;
    });
    const blockHash = locationInfo.block.block.header.hash;
    const rawStatus = (0, conversion_1.createRawExtrinsicStatus)('Finalized', blockHash, context);
    return new api_1.SubmittableResult({
        blockNumber: locationInfo.block.block.header.number.unwrap(),
        txIndex: locationInfo.txIndex,
        txHash,
        status: rawStatus,
        events: relatedEvents,
    });
});
exports.pollForTransactionFinalization = pollForTransactionFinalization;
//# sourceMappingURL=utils.js.map